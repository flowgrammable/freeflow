/* Wolfram Symbolic Transfer Protocol (WSTP)
 *
 * 'Packet' Types (structural bundles of messages to/from the Kernel:
 * https://reference.wolfram.com/language/ref/c/WSNextPacket.html
 *
 * Function Call Interface:
 * CALLPKT	CallPacket[integer,list]	request to invoke the external function numbered integer with arguments list
 * ENTEREXPRPKT	EnterExpressionPacket[expr]	evaluate expr
 * RETURNEXPRPKT	ReturnExpressionPacket[expr]	result of EnterExpressionPacket[] evaluation
 * EVALUATEPKT	EvaluatePacket[expr]	evaluate expr while avoiding the kernel main loop
 * RETURNPKT	ReturnPacket[expr]	result of a calculation
 * ENTERTEXTPKT	EnterTextPacket[string]	parse string and evaluate as an expression
 * RETURNTEXTPKT	ReturnTextPacket[string]	formatted text representation of a result
 *
 * Variable I/O:
 * INPUTNAMEPKT	InputNamePacket[string]	name to be assigned to the next input (usually In[n]:=)
 * INPUTPKT	InputPacket[]	prompt for input, as generated by the Wolfram Language's Input[] function
 * INPUTSTRPKT	InputStringPacket[]	request input as a string
 * OUTPUTNAMEPKT	OutputNamePacket[string]	name to be assigned to the next output (usually Out[n]=)
 * MENUPKT	MenuPacket[integer,string]	menu request with title string
 *
 * Dialog I/O:
 * BEGINDLGPKT	BeginDialogPacket[integer]	start a dialog subsession referenced by integer
 * ENDDLGPKT	EndDialogPacket[integer]	end the dialog subsession referenced by integer
 *
 * Language Error Handling:
 * MESSAGEPKT	MessagePacket[symbol,string]	Wolfram Language message identifier (symbol::string)
 * SYNTAXPKT	SyntaxPacket[integer]	position at which a syntax error was detected in the input line
 * TEXTPKT	TextPacket[string]	text output from the Wolfram Language, as produced by Print[]
 *
 * Depcricated:
 * DISPLAYENDPKT	DisplayEndPacket[]	obsolete PostScript graphics-related packet
 * DISPLAYPKT	DisplayPacket[]	obsolete PostScript graphics-related packet
 * RESUMEPKT	ResumePacket[]	obsolete packet
 * SUSPENDPKT	SuspendPacket[]	obsolete packet
 */

#include "wstp_link.hpp"

#include <iostream>
#include <sstream>

using pkt_id_t = wstp_link::pkt_id_t;

// Forward declarations of get/put specilizations:
template<> int wstp_link::get<int>();
template<> int64_t wstp_link::get<int64_t>();
template<> double wstp_link::get<double>();
template<> std::string wstp_link::get<std::string>();
template<> int wstp_link::put<int64_t>(int64_t);
template<> int wstp_link::put<double>(double);
template<> int wstp_link::put<std::string>(std::string);
template<> int wstp_link::put<const char*>(const char*);
template<> int wstp_link::put_function<std::string>(std::string, int);
template<> int wstp_link::put_function<const char*>(const char*, int);
template<> int wstp_link::put_function<int64_t>(int64_t, int);
template<> int wstp_link::put_symbol<std::string>(std::string);
template<> int wstp_link::put_symbol<const char*>(const char*);

// Initialize static member variables:
bool wstp_link::quit_all_ = false;

extern "C" {
#include <csignal>

// Define handler with C ABI for error callback:
void err_handler(WSLINK link, int msg, int arg) {
  switch (msg) {
  case WSInterruptMessage:
    std::cerr << "WSInterruptMessage callback message." << std::endl;
    break;
  case WSAbortMessage:
    std::cerr << "WSAbortMessage callback message." << std::endl;
    break;
  case WSTerminateMessage:
    std::cerr << "WSTerminateMessage callback message." << std::endl;
    break;
  default:
    std::cerr << "WARNING: Unexpected callback message type: " << msg << std::endl;
  }
}
// Define handler with C ABI for signal handling callback:
void sig_handler(int signal) {
  std::cerr << "Signal " << signal << " received;";
  switch (signal) {
  case SIGINT:
    std::cerr << " exiting." << std::endl;
    std::exit(EXIT_SUCCESS);
  default:
    std::cerr << " no action." << std::endl;
  }
}
}

wstp_link::wstp_link(std::string args) : env_(nullptr), link_(nullptr),
  worker_stop_(false) {
  WSEnvironmentParameter p = WSNewParameters(WSREVISION, WSAPIREVISION);
  if (p) {
//    WSDoNotHandleSignalParameter(p, SIGINT);
  }
  else {
    std::cerr << "Failed to create WSEnviornmentParameter." << std::endl;
  }
  env_ = WSInitialize(p);
  if (!env_)
    throw std::string("Failed WSInitialize.");

  int err = 0;
  link_ = WSOpenString(env_, args.c_str(), &err);
  if(!link_ || err != WSEOK) {
    std::cerr << "WSOpenString Error: " << err << std::endl;
    throw std::string("Failed WSOpenString.");
  }

  if (!(err = WSActivate(link_))) {
    std::cerr << "WSActivate Error: " << err << std::endl;
    throw print_error();
  }

  log("wstp.log");

  WSSetSignalHandlerFromFunction(env_, SIGINT, sig_handler);
  if (error()) {
    print_error();
  }
}

wstp_link::wstp_link(int argc, const char* argv[]) : env_(nullptr), link_(nullptr),
  worker_stop_(false) {
  WSEnvironmentParameter p = WSNewParameters(WSREVISION, WSAPIREVISION);
  if (p) {
//    WSDoNotHandleSignalParameter(p, SIGINT);
  }
  else {
    std::cerr << "Failed to create WSEnviornmentParameter." << std::endl;
  }
  env_ = WSInitialize(p);
  if (!env_)
    throw std::string("Failed WSInitialize.");

  int err = 0;
  link_ = WSOpenArgcArgv(env_, argc, const_cast<char**>(argv), &err);
  if(!link_ || err != WSEOK) {
    std::cerr << "WSOpenArgcArgv Error: " << err << std::endl;
    throw std::string("Failed WSOpenArgcArgv.");
  }

  if (!(err = WSActivate(link_))) {
    std::cerr << "WSActivate Error: " << err << std::endl;
    throw print_error();
  }

  log("wstp.log");

  WSSetSignalHandlerFromFunction(env_, SIGINT, sig_handler);
  if (error()) {
    print_error();
  }
}

wstp_link::~wstp_link() {
  worker_stop_ = true;
  deinit();
  closelink();
  worker_.join();
}

wsint64 wstp_link::close_fn() {
  worker_stop_ = true;
  quit_all_ = true;
  return 0;
}

wsint64 wstp_link::wakeup_fn() {
  // check for any compute jobs, then return...
  return 0;
}

int wstp_link::install(std::vector<def_t>& definitions) {
  int count = 0;
  // TODO: BeginPackage is not a standard atomic function...
  // - It looks like a raw string should be sent for evauluation...
//  count += put_function("BeginPackage", 1);
//  count += put("counter`");
  // Send Mathematica definitions to external function:
  constexpr auto close = std::make_tuple("FFClose[]", "", 0);
  worker_fTable_.emplace_back( std::bind(&wstp_link::close_fn, this) );
  count += put_function("DefineExternal", 3);
  count += put(close);

  constexpr auto wakeup = std::make_tuple("FFWakeup[]", "", 1);
  worker_fTable_.emplace_back( std::bind(&wstp_link::wakeup_fn, this) );
  count += put_function("DefineExternal", 3);
  count += put(wakeup);

  for (auto& d : definitions) {
    auto pattern = std::make_tuple(std::get<1>(d), std::get<2>(d),
                                   static_cast<int>(worker_fTable_.size()));
    worker_fTable_.emplace_back(std::get<0>(d));
    count += put_function("DefineExternal", 3);
    count += put(pattern);
  }
//  count += put_function("EndPackage", 0);
  count += put_symbol("End");
  flush();

  if (error()) {
    print_error();
  }

  // start thread to serve as function handler:
  worker_ = std::thread(&wstp_link::receive_worker, this);

  return count;
}

void wstp_link::receive_worker() {
  std::cout << "WSTP worker thread started." << std::endl;
  try {
  if (!WSSetMessageHandler(link_, err_handler)) {
    std::cerr << "WARNING: unable to set wstp error message handler." << std::endl;
    print_error();
  }
  while (!worker_stop_) {
//    std::cerr << "DEBUG: worker waiting on receive()" << std::endl;
    if (ready()) {
      pkt_id_t id = receive();
      if (error()) {
        print_error();
        break;
      }
    }
    else {
      std::this_thread::sleep_for(std::chrono::seconds(1));
    }
  }
  } catch (std::string s) {
    std::cerr << "ERROR: Caught expection in wstp interface:\n" << s << std::endl;
  }
  std::cout << "WSTP worker thread terminated." << std::endl;
}

void wstp_link::wait() {
  while(!quit_all_) {
    // TODO: need some way of restarting connection on failure?
    std::this_thread::sleep_for(std::chrono::seconds(10));
  }
}

void wstp_link::closelink(void) {
  worker_stop_ = true;
  if (link_)
    WSClose(link_);
  link_ = nullptr;
}

void wstp_link::deinit(void) {
  if (env_)
    WSDeinitialize(env_);
  env_ = nullptr;
}

int wstp_link::ready() {
  flush();
  int i;
  if (!(i=WSReady(link_))) {
    print_error();
  }
  return i;
}

int wstp_link::flush() {
  int i;
  if (!(i=WSFlush(link_))) {
    print_error();
  }
  return i;
}

int wstp_link::reset() {
  if (!WSClearError(link_)) {
    throw print_error();
  }
  if (!WSNewPacket(link_)) {
    throw print_error();
  }
  return 0;
}

int wstp_link::error() const {
  return WSError(link_);
}

std::string wstp_link::get_error() const {
  if ( int code = WSError(link_) ) {
    const char* err = WSErrorMessage(link_);
    std::stringstream ss;
    ss << "wstp_link error " << code << ": " << err;
    WSReleaseErrorMessage(link_, err);
    return ss.str();
  } else {
    return std::string();
  }
}

std::string wstp_link::print_error() const {
  if (error()) {
    std::string err = get_error();
    std::cerr << err << std::endl;
    return err;
  }
  return std::string();
}

bool wstp_link::log(std::string filename) {
  if (!WSLogStreamToFile(link_, filename.c_str())) {
    print_error();
    return false;
  }
  return true;
}

int wstp_link::decode_call() {
  int funcID = get<int>();
  if (funcID < 0 || funcID >= worker_fTable_.size()) {
    std::cerr << "Unrecognized Function ID: " << funcID << std::endl;
    return 0;
  }

  // TODO: flexibility is broken, need a good way to compose function calls:
  put_function("ReturnPacket", 1);
  switch (funcID) {
  case 0: // exit
    break;
  case 1: // wakeup
    break;
  case 2: // get_arrival
  {
    return_t v = worker_fTable_[funcID](0);
    if (std::holds_alternative<ts_t>(v)) {
      ts_t events = std::get<ts_t>(v);
      std::cout << "Returning list of size: " << events.size()-1 << std::endl;
      WSPutInteger64List(link_, events.data()+1, static_cast<int>(events.size()-1));
    }
    break;
  }
  case 3: // get_misses_MIN
  {
    return_t v = worker_fTable_[funcID](0);
    if (std::holds_alternative<ts_t>(v)) {
      ts_t events = std::get<ts_t>(v);
      std::cout << "Returning list of size: " << events.size()-1 << std::endl;
      WSPutInteger64List(link_, events.data()+1, static_cast<int>(events.size()-1));
    }
    break;
  }
  case 4: // get_num_flows
  {
    return_t v = worker_fTable_[funcID](0);
    if (std::holds_alternative<wsint64>(v)) {
      auto count = std::get<wsint64>(v);
      WSPutInteger64(link_, count);
    }
    break;
  }
  default:
    std::cerr << "Unexpected funcID: " << funcID << std::endl;
  }
  put_end();
  flush();
  return funcID;
}

pkt_id_t wstp_link::receive() {
  // Skip any unconsumed data if needed:
begin:
  if (!WSNewPacket(link_)) {
    print_error();
    reset();
  }

  // Get ID of next packet:
  pkt_id_t pkt_id = WSNextPacket(link_);
  switch (pkt_id) {
  case CALLPKT:
//    std::cerr << "Call WSTP Packet type." << std::endl;
    decode_call();
    break;
  case EVALUATEPKT:
    std::cerr << "Evaluate WSTP Packet type." << std::endl;
    break;
  case RETURNPKT:
    std::cerr << "Return WSTP Packet type." << std::endl;
    break;
  case ILLEGALPKT:
    if (error() == 11) {
      worker_stop_ = true;
    }
    print_error();
    reset();
//    goto begin; // break
    return pkt_id;
  default:
    std::cerr << "Unsupported WSTP Packet type; ignoring..." << std::endl;
    goto begin;
  }

  if (error()) {
    print_error();
  }
  return pkt_id;  // TODO: repeat until packet is fully received?
}

pkt_id_t wstp_link::receive(const pkt_id_t id) {
  pkt_id_t rid;
  while((rid = receive()) != id) {
    std::cerr << "Skipping Packet with ID " << rid
              << ", waiting for " << id << std::endl;
  }
  return rid;
}

// Example Test Functions:
int wstp_link::factor_test(int n) {
  std::cout << "Factors of " << n << ":\n";

  // Send actual Mathematica command:
  WSPutFunction(link_, "EvaluatePacket", 1L);
  WSPutFunction(link_, "FactorInteger", 1L);
  WSPutInteger(link_, n);
  WSEndPacket(link_);

  int pkt = 0;
  // Skip everything until Return packet type is found:
  while( (pkt = WSNextPacket(link_)) != RETURNPKT) {
    WSNewPacket(link_);
    if (error()) {
      throw print_error();
    }
  }

  // Expect list returned; len holds list length:
  int len = 0;
  if ( !WSTestHead(link_, "List", &len) ) {
    std::cerr << "WSTestHead is NULL" << std::endl;
    if (error()) {
      throw print_error();
    }
  }

  // For each element in list,
  for (int k = 1; k <= len; k++) {
    int lenp = 0, prime = 0, expt = 0;
    if (WSTestHead(link_, "List", &lenp)
        &&  lenp == 2
        &&  WSGetInteger(link_, &prime)
        &&  WSGetInteger(link_, &expt) )
    {
      std::cout << prime << " ^ " << expt << std::endl;
    } else {
      std::cerr << "Failed to decode WSTestHead" << std::endl;
      throw print_error();
    }
  }

//  WSPutFunction(link_, "Exit", 0);
  return EXIT_SUCCESS;
}

int wstp_link::factor_test2(int n) {
  std::cout << "Factors of " << n << ":\n";

  // Send Mathematica command to Factor integer:
  auto factorCMD = std::make_tuple("FactorInteger", int64_t(n));
  put_function(factorCMD);

  using prime_t = int64_t;
  using expt_t = int64_t;
  using factor_t = std::tuple<prime_t, expt_t>;

  auto factors = receive_list<factor_t>();
  for (factor_t f : factors) {
    std::cout << std::get<0>(f) << " ^ " << std::get<1>(f) << std::endl;
  }
  return EXIT_SUCCESS;
}


/// Specilizations to get items from link ///
// Helpers:
void replace_all(std::string& str, std::string match, std::string replace) {
  auto pos = str.find(match);
  while (pos != str.npos) {
    str.replace(pos, match.size(), replace);
    pos = str.find(match, pos+replace.size());
  }
}

// Integer elements:
template<>
int64_t wstp_link::get<int64_t>() {
  static_assert(sizeof(wsint64) == sizeof(int64_t), "wsint64 is not 64-bits!");
//  std::cerr << "DEBUG: Called get<int64_t>()";
  wsint64 i;
  if (!WSGetInteger64(link_, &i)) {
    std::cerr << std::endl;
    print_error();
    reset();
  }
//  std::cerr << " = " << i << std::endl;
  return i;
}

template<>
int wstp_link::get<int>() {
//  std::cerr << "DEBUG: Called get<int>()";
  int i;
  if (!WSGetInteger(link_, &i)) {
    std::cerr << std::endl;
    print_error();
    reset();
  }
//  std::cerr << " = " << i << std::endl;
  return i;
}

// Real elements:
template<>
double wstp_link::get<double>() {
//  std::cerr << "DEBUG: Called get<double>()";
  double r;
  if (!WSGetReal64(link_, &r)) {
    std::cerr << std::endl;
    print_error();
    reset();
  }
//  std::cerr << " = " << r << std::endl;
  return r;
}

// String elements:
template<>
std::string wstp_link::get<std::string>() {
  std::cerr << "DEBUG: Called get<std::string>()";
  const char* cstr;
  if (!WSGetString(link_, &cstr)) {
    std::cerr << std::endl;
    print_error();
    reset();
  }
  std::string s(cstr);
  WSReleaseString(link_, cstr);

  replace_all(s, "\\\\", "\\");  // Mathematica requires all '\' to be escaped.
  std::cerr << " = " << s << std::endl;
  return s;
}


/// Push item to link specilizations ///
// Integer elements:
template<>
int wstp_link::put<int64_t>(int64_t i) {
  static_assert(sizeof(wsint64) == sizeof(int64_t), "wsint64 is not 64-bits!");
//  std::cerr << "DEBUG: Called put<int64_t>(" << i << ")" << std::endl;
  if (!WSPutInteger64(link_, i)) {
    print_error();
    reset();
    return 0;
  }
  return 1;
}
//WSPutInteger
template<>
int wstp_link::put<int>(int i) {
//  std::cerr << "DEBUG: Called put<int>(" << i << ")" << std::endl;
  if (!WSPutInteger(link_, i)) {
    print_error();
    reset();
    return 0;
  }
  return 1;
}
//template<>
//int wstp_link::put<std::vector<int64_t>>(std::vector<int64_t> list) const {
//  static_assert(sizeof(wsint64) == sizeof(int64_t), "wsint64 is not 64-bits!");
//  std::cerr << "DEBUG: Called put<std::vector<int64_t>>(length(" << list.size() << "))" << std::endl;
//  if (!WSPutInteger64(link_, i)) {
//    print_error();
//    reset();
//    return 0;
//  }
//  return 1;
//}

// Real elements:
template<>
int wstp_link::put<double>(double r) {
//  std::cerr << "DEBUG: Called put<double>(" << r << ")" << std::endl;
  if (!WSPutReal64(link_, r)) {
    print_error();
    reset();
    return 0;
  }
  return 1;
}

// String elements:
template<>
int wstp_link::put<std::string>(std::string s) {
//  std::cerr << "DEBUG: Called put<string>(" << s << ")" << std::endl;
  replace_all(s, "\\", "\\\\");  // Mathematica requires all '\' to be escaped.
  if (!WSPutString(link_, s.c_str())) {
    print_error();
    reset();
    return 0;
  }
  return 1;
}
template<>
int wstp_link::put<const char*>(const char* cstr) {
  return put(std::string(cstr));
}


// Function:
template<>
int wstp_link::put_function<std::string>(std::string s, int args) {
//  std::cerr << "DEBUG: Called put_function<string>(" << s << ")" << std::endl;
  if (!WSPutFunction(link_, s.c_str(), args)) {
    print_error();
    reset();
    return 0;
  }
  return 1;
}
template<>
int wstp_link::put_function<const char*>(const char* cstr, int args) {
  return put_function(std::string(cstr), args);
}

// Symbol:
template<>
int wstp_link::put_symbol<std::string>(std::string s) {
//  std::cerr << "DEBUG: Called put_symbol<string>(" << s << ")" << std::endl;
  if (!WSPutSymbol(link_, s.c_str())) {
    print_error();
    reset();
    return 0;
  }
  return 1;
}
template<>
int wstp_link::put_symbol<const char*>(const char* cstr) {
  return put_symbol(std::string(cstr));
}

// TODO: this seems like a hack and should be factored out?
template<>
int wstp_link::put_function<int64_t>(int64_t i, int) {
  return put(i);
}

int wstp_link::put_end() {
//  std::cerr << "DEBUG: Called put_end()" << std::endl;
  if (!WSEndPacket(link_)) {
    print_error();
    reset();
    return 0;
  }
  return 1;
}
